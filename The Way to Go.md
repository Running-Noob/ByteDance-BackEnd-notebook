# The Way to Go

- 鉴于字节跳动训练营中关于 `Go` 语言方面的介绍过于简洁凝练，所以额外阅读了 [《The Way to Go》即《Go 入门指南》](https://github.com/unknwon/the-way-to-go_ZH_CN) ，并做以下笔记，来帮助自己对 `Go` 有一个更清晰的认识。
- 注意：本笔记仅记录我认为有必要记录的地方，如果想知道全部细节，请阅读上面提到的 `《Go入门指南》` 。

## 02 安装与运行环境

### 2.2 Go环境变量

- Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 `c:/go` 下。这里列举几个最为重要的环境变量：

  - **$GOROOT** 表示 Go 在你的电脑上的安装位置，它的值一般都是 `$HOME/go`，当然，你也可以安装在别的地方。
  - **$GOARCH** 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。
  - **$GOOS** 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。
  - **$GOBIN** 表示编译器和链接器的安装位置，默认是 `$GOROOT/bin`，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。

  目标机器是指你打算运行你的 Go 应用程序的机器。

  - **$GOPATH** 默认采用和 `$GOROOT` 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：`src`、`pkg` 和 `bin`，这三个目录分别用于存放源码文件、包文件和可执行文件。
  - **$GOARM** 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。
  - **$GOMAXPROCS** 用于设置应用程序可使用的处理器个数与核数。

### 2.7 Go运行时runtime

- 尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 `runtime` 包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收（[第 10.8 节](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.8.md)）、栈处理、goroutine、channel、切片 (slice)、map 和反射 (reflection) 等等。

## 03 编辑器、集成开发环境与其它工具

### 3.2 编辑器和集成开发环境

- 这些编辑器包含了代码高亮和其它与 Go 有关的一些使用工具：Emacs、Vim、Xcode 6、KD Kate、TextWrangler、BBEdit、McEdit、TextMate、TextPad、JEdit、SciTE、Nano、Notepad++、Geany、SlickEdit、**Visual Studio Code**、IntelliJ IDEA 和 Sublime Text 2。
- **代码补全** 一般都是通过内置 GoCode 实现的（如：LieteIDE、GoClipse），如果需要手动安装 GoCode，在命令行输入指令 `go get -u github.com/nsf/gocode` 即可（务必事先配置好 Go 环境变量） 。

### 3.4 构建并运行 Go 程序

- 在大多数 IDE 中，每次构建程序之前都会自动调用源码格式化工具 `gofmt` 并保存格式化后的源文件。如果构建成功则不会输出任何信息，而当发生编译时错误时，则会指明源码中具体第几行出现了什么错误，如：`a declared and not used`。一般情况下，你可以双击 IDE 中的错误信息直接跳转到发生错误的那一行。

  如果程序执行一切顺利并成功退出后，将会在控制台输出 `Program exited with code 0`。

  从 Go 1 版本开始，使用 Go 自带的更加方便的工具来构建应用程序：

  - `go build` 编译自身包和依赖包
  - `go install` 编译并安装自身包和依赖包

### ★3.5 格式化代码

- Go 开发团队不想要 Go 语言像许多其它语言那样总是在为代码风格而引发无休止的争论，浪费大量宝贵的开发时间，因此他们制作了一个工具：`go fmt` (gofmt)。这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。遵循统一的代码风格是 Go 开发中无可撼动的铁律，因此你必须在编译或提交版本管理系统之前使用 gofmt 来格式化你的代码。

  尽管这种做法也存在一些争论，但使用 gofmt 后你不再需要自成一套代码风格而是和所有人使用相同的规则。这不仅增强了代码的可读性，而且在接手外部 Go 项目时，可以更快地了解其代码的含义。此外，大多数开发工具也都内置了这一功能。

  Go 对于代码的缩进层级方面使用 tab 还是空格并没有强制规定，一个 tab 可以代表 4 个或 8 个空格。在实际开发中，1 个 tab 应该代表 4 个空格，而在本身的例子当中，每个 tab 代表 8 个空格。至于开发工具方面，一般都是直接使用 tab 而不替换成空格。

  **在命令行输入 `gofmt –w program.go` 会格式化该源文件的代码然后将格式化后的代码覆盖原始内容（如果不加参数 `-w` 则只会打印格式化后的结果而不重写文件）**；`gofmt -w *.go` 会格式化并重写所有 Go 源文件；`gofmt map1` 会格式化并重写 `map1` 目录及其子目录下的所有 Go 源文件。

  `gofmt` 也可以通过在参数 `-r` 后面加入用双引号括起来的替换规则实现代码的简单重构，规则的格式：`<原始内容> -> <替换内容>`。

  实例：

  ```shell
  gofmt -r '(a) -> a' –w *.go
  ```

  上面的代码会将源文件中没有意义的括号去掉。

  ```shell
  gofmt -r 'a[n:len(a)] -> a[n:]' –w *.go
  ```

  上面的代码会将源文件中多余的 `len(a)` 去掉。（ **译者注：了解切片 (slice) 之后就明白这为什么是多余的了** ）

  ```shell
  gofmt –r 'A.Func1(a,b) -> A.Func2(b,a)' –w *.go
  ```

  上面的代码会将源文件中符合条件的函数的参数调换位置。

### 3.6 生成代码文档

- godoc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。

- 它也可以作为一个提供在线文档浏览的 web 服务器，[http://golang.org](http://golang.org/) 就是通过这种形式实现的。

  **一般用法**：

  - `go doc package` 获取包的文档注释，例如：`go doc fmt` 会显示使用 godoc 生成的 `fmt` 包的文档注释。
  - `go doc package/subpackage` 获取子包的文档注释，例如：`go doc container/list`。
  - `go doc package function` 获取某个函数在某个包中的文档注释，例如：`go doc fmt Printf` 会显示有关 `fmt.Printf()` 的使用说明。

  这个工具只能获取在 Go 安装目录下 `../go/src` 中的注释内容。

- 此外，它还可以作为一个本地文档浏览 web 服务器。在命令行输入 `godoc -http=:6060`，然后使用浏览器打开 [http://localhost:6060](http://localhost:6060/) 后，你就可以看到本地文档浏览服务器提供的页面。

### 3.7 其它工具

- Go 自带的工具集主要使用脚本和 Go 语言自身编写的，目前版本的 Go 实现了以下三个工具：
  - `go install` 是安装 Go 包的工具，类似 Ruby 中的 rubygems。主要用于安装非标准库的包文件，将源代码编译成对象文件。
  - `go fix` 用于将你的 Go 代码从旧的发行版迁移到最新的发行版，它主要负责简单的、重复的、枯燥无味的修改工作，如果像 API 等复杂的函数修改，工具则会给出文件名和代码行数的提示以便让开发人员快速定位并升级代码。Go 开发团队一般也使用这个工具升级 Go 内置工具以及 谷歌内部项目的代码。`go fix` 之所以能够正常工作是因为 Go 在标准库就提供生成抽象语法树和通过抽象语法树对代码进行还原的功能。该工具会尝试更新当前目录下的所有 Go 源文件，并在完成代码更新后在控制台输出相关的文件名称。
  - `go test` 是一个轻量级的单元测试框架（[第 13 章](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.0.md)）。

## 04 基本结构和基本数据类型

### 4.1 文件名、关键字与标识符

- Go 的源文件以 `.go` 为后缀名存储在计算机中，这些文件名均由小写字母组成，如 `scanner.go` 。如果文件名由多个部分组成，则使用下划线 `_` 对它们进行分隔，如 `scanner_test.go` 。文件名不包含空格或其他特殊字符。

  一个源文件可以包含任意多行的代码，Go 本身没有对源文件的大小进行限制。

- 你会发现在 Go 代码中的几乎所有东西都有一个名称或标识符。另外，Go 语言也是区分大小写的，这与 C 家族中的其它语言相同。有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 `_`）开头，然后紧跟着 0 个或多个字符或 Unicode 数字，如：X56、group1、_x23、i、өԑ12

  以下是无效的标识符：

  - 1ab（以数字开头）

  - case（Go 语言的关键字）

  - a+b（运算符是不允许的）

  **`_` 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。**

- 在编码过程中，你可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。

- 下面列举了 Go 代码中会使用到的 25 个关键字或保留字：

  | break    | default     | func   | interface | select |
  | -------- | ----------- | ------ | --------- | ------ |
  | case     | defer       | go     | map       | struct |
  | chan     | else        | goto   | package   | switch |
  | const    | fallthrough | if     | range     | type   |
  | continue | for         | import | return    | var    |

  之所以刻意地将 Go 代码中的关键字保持的这么少，是为了简化在编译过程第一步中的代码解析。和其它语言一样，关键字不能够作标识符使用。

- 程序一般由关键字、常量、变量、运算符、类型和函数组成。

  程序中可能会使用到这些分隔符：括号 `()`，中括号 `[]` 和大括号 `{}`。

  程序中可能会使用到这些标点符号：`.`、`,`、`;`、`:` 和 `…`。

  程序的代码通过语句来实现结构化。**每个语句不需要像 C 家族中的其它语言一样以分号 `;` 结尾，因为这些工作都将由 Go 编译器自动完成。**

  如果你打算将多个语句写在同一行，它们则必须使用 `;` 人为区分，但在实际开发中我们并不鼓励这种做法。

### 4.2 Go 程序的基本结构和要素

- 示例 4.1 [hello_world.go](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_4/hello_world.go)

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	fmt.Println("hello, world")
  }
  ```

#### 4.2.1 包的概念、导入与可见性

##### 包的概念

- 包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。

  如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。**一个包可以由许多以 `.go` 为扩展名的源文件组成**，因此文件名和包名一般来说都是不相同的。

  你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：`package main`。**`package main` 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 `main` 的包。**

  **一个应用程序可以包含不同的包**，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 `package main` 来指明这些文件都属于 `main` 包。如果你打算编译包名不是为 main 的源文件，如 `pack1`，编译后产生的对象文件将会是 `pack1.a` 而不是可执行程序。另外要注意的是，**所有的包名都应该使用小写字母。**

- **标准库**：在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。Go 的标准库包含了大量的包（如：`fmt` 和 `os`），但是你也可以创建自己的包（[第 9 章](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.0.md)）。

- 如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。**包的依赖关系决定了其构建顺序**。

  属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。

  **如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。**

- Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 `.o` 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。

  如果 `A.go` 依赖 `B.go`，而 `B.go` 又依赖 `C.go`：

  - 编译 `C.go`, `B.go`, 然后是 `A.go`.
  - 为了编译 `A.go`, 编译器读取的是 `B.o` 而不是 `C.o`.

  这种机制对于编译大型的项目时可以显著地提升编译速度。

- **每一段代码只会被编译一次**

##### 包的导入

- **一个 Go 程序是通过 `import` 关键字将一组包链接在一起。**

  `import "fmt"` 告诉 Go 编译器这个程序需要使用 `fmt` 包（的函数，或其他元素），`fmt` 包实现了格式化 IO（输入/输出）的函数。包名被封闭在半角双引号 `""` 中。如果你打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。

  如果需要多个包，它们可以被分别导入：

  ```go
  import "fmt"
  import "os"
  ```

  或：

  ```go
  import "fmt"; import "os"
  ```

  但是还有更短且更优雅的方法（被称为因式分解关键字，该方法同样适用于 `const`、`var` 和 `type` 的声明或定义）：

  ```go
  import (
     "fmt"
     "os"
  )
  ```

  它甚至还可以更短的形式，但使用 `gofmt` 后将会被强制换行：

  ```go
  import ("fmt"; "os")
  ```

  当你导入多个包时，最好按照字母顺序排列包名，这样做更加清晰易读。

- 如果包名不是以 `.` 或 `/` 开头，如 `"fmt"` 或者 `"container/list"`，则 Go 会在全局文件进行查找；如果包名以 `./` 开头，则 Go 会在相对目录中查找；如果包名以 `/` 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。

- 导入包即等同于包含了这个包的所有的代码对象。

  除了符号 `_`，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是**相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们**。

##### 包的代码对象的可见性

- 包通过下面这个被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件：

  - **可见性规则**：当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个**大写字母开头**，如：Group1，那么**使用这种形式的标识符的对象就可以被外部包的代码所使用**（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以**小写字母开头**，则**对包外是不可见的**，但是它们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。

    （大写字母可以使用任何 Unicode 编码的字符，比如希腊文，不仅仅是 ASCII 码中的大写字母）。

  因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。

  - 假设在包 `pack1` 中我们有一个变量或函数叫做 `Thing`（以 T 开头，所以它能够被导出），那么在当前包中导入 `pack1` 包，`Thing` 就可以像面向对象语言那样使用点标记来调用：`pack1.Thing`（pack1 在这里是不可以省略的）。

    因此包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于它们的包名，例如 `pack1.Thing` 和 `pack2.Thing`。

- 你可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如：`import fm "fmt"`。下面的代码展示了如何使用包的别名：

  示例 4.2 [alias.go](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_4/alias.go) 

  ```go
  package main
  
  import fm "fmt" // alias3
  
  func main() {
     fm.Println("hello, world")
  }
  ```

  - **注意事项**

    如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 `imported and not used: os`，这正是遵循了 Go 的格言：“没有不必要的代码！”。

- **包的分级声明和初始化**

  你可以在使用 `import` 导入包之后定义或声明 0 个或多个常量 (const)、变量 (var) 和类型 (type)，这些对象的作用域都是全局的（在本包范围内），所以可以被本包中所有的函数调用（如 [gotemplate.go](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_4/gotemplate.go) 源文件中的 `c` 和 `v`），然后声明一个或多个函数 (func)。

#### 4.2.2 函数

- 这是定义一个函数最简单的格式：

  ```go
  func functionName()
  ```

  你可以在括号 `()` 中写入 0 个或多个函数的参数（使用逗号 `,` 分隔），**每个参数的名称后面必须紧跟着该参数的类型**。

- `main()` 函数是每一个**可执行程序**所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 `init()` 函数则会先执行该函数）。如果你的 `main` 包的源代码没有包含 `main()` 函数，则会引发构建错误 `undefined: main.main`。`main()` 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 `main()` 函数添加了参数或者返回类型，将会引发构建错误：

  ```
  func main must have no arguments and no return values results.
  ```

  在程序开始执行并完成初始化后，第一个调用（程序的入口点）的函数是 `main.main()`（如：C 语言），该函数一旦返回就表示程序已成功执行并立即退出。

- 函数里的代码（函数体）使用大括号 `{}` 括起来。

  **左大括号 `{` 必须与方法的声明放在同一行，这是编译器的强制规定**，否则你在使用 gofmt 时就会出现错误提示：

  ```
  `build-error: syntax error: unexpected semicolon or newline before {`
  ```

  （这是因为编译器会产生 `func main() ;` 这样的结果，很明显这是错误的）

  **Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误**

  **右大括号 `}` 需要被放在紧接着函数体的下一行。**如果你的函数非常简短，你也可以将它们放在同一行：

  ```go
  func Sum(a, b int) int { return a + b }
  ```

  **对于大括号 `{}` 的使用规则在任何时候都是相同的**（如：`if` 语句等）。

  **因此符合规范的函数一般写成如下的形式：**

  ```go
  func functionName(parameter_list) (return_value_list) {
     …
  }
  ```

  **其中：**

  - **`parameter_list` 的形式为 `(param1 type1, param2 type2, …)`**
  - **`return_value_list` 的形式为 `(ret1 type1, ret2 type2, …)`**

  只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。

  下面这一行调用了 `fmt` 包中的 `Println` 函数，可以将字符串输出到控制台，并在最后自动增加换行字符 `\n`：

  ```go
  fmt.Println（"hello, world"）
  ```

  使用 `fmt.Print("hello, world\n")` 可以得到相同的结果。

  `Print` 和 `Println` 这两个函数也支持使用变量，如：`fmt.Println(arr)`。如果没有特别指定，它们会以默认的打印格式将变量 `arr` 输出到控制台。

  单纯地打印一个字符串或变量甚至可以使用预定义的方法来实现，如：`print`、`println：print("ABC")`、`println("ABC")`、`println(i)`（带一个变量 `i`）。

  这些函数只可以用于调试阶段，在部署程序的时候务必将它们替换成 `fmt` 中的相关函数。

  当被调用函数的代码执行到结束符 `}` 或返回语句时就会返回，然后程序继续执行调用该函数之后的代码。

  程序正常退出的代码为 `0` 即 `Program exited with code 0`；如果程序因为异常而被终止，则会返回非零值，如：`1`。这个数值可以用来测试是否成功执行一个程序。